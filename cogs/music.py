import discord
from discord import app_commands
from discord.ext import commands
import asyncio
import yt_dlp
import functools
from enum import Enum
import math
import logging
import os
import random
import aiohttp
import re
from typing import Union, Optional

# === THI·∫æT L·∫¨P V√Ä CLASS HELPER ===
log = logging.getLogger(__name__)
AnyContext = Union[commands.Context, discord.Interaction]
YTDL_SEARCH_OPTIONS = {'format':'bestaudio/best','noplaylist':True,'nocheckcertificate':True,'ignoreerrors':False,'logtostderr':False,'quiet':True,'no_warnings':True,'default_search':'ytsearch10','source_address':'0.0.0.0','extract_flat':'search'}
YTDL_DOWNLOAD_OPTIONS = {'format':'bestaudio[ext=m4a]/bestaudio/best','outtmpl':'cache/%(id)s.%(ext)s','restrictfilenames':True,'noplaylist':True,'nocheckcertificate':True,'ignoreerrors':False,'logtostderr':False,'quiet':True,'no_warnings':True,'source_address':'0.0.0.0','cachedir':False}
FFMPEG_OPTIONS = {'before_options':'','options':'-vn'}
class LoopMode(Enum): OFF = 0; SONG = 1; QUEUE = 2

class Song:
    """ƒê·∫°i di·ªán cho m·ªôt b√†i h√°t."""
    def __init__(self, data, requester: discord.Member | discord.User):
        self.requester = requester; self.data = data; self.url = data.get('webpage_url') or data.get('url')
        self.title = data.get('title'); self.thumbnail = data.get('thumbnail'); self.duration = data.get('duration')
        self.uploader = data.get('uploader'); self.filepath = None; self.id = data.get('id')
    def format_duration(self):
        if self.duration is None: return "N/A"
        m, s = divmod(self.duration, 60); h, m = divmod(m, 60)
        return f"{int(h):02d}:{int(m):02d}:{int(s):02d}" if h > 0 else f"{int(m):02d}:{int(s):02d}"
    def cleanup(self):
        if self.filepath and os.path.exists(self.filepath):
            try: os.remove(self.filepath); log.info(f"ƒê√£ x√≥a file cache: {self.filepath}")
            except OSError as e: log.error(f"L·ªói khi x√≥a file cache {self.filepath}: {e}")
    @classmethod
    async def search_only(cls, query: str, requester: discord.Member | discord.User):
        loop = asyncio.get_running_loop()
        partial = functools.partial(yt_dlp.YoutubeDL(YTDL_SEARCH_OPTIONS).extract_info, query, download=False)
        try:
            data = await loop.run_in_executor(None, partial);
            if not data or 'entries' not in data or not data['entries']: return []
            return [cls(entry, requester) for entry in data['entries']]
        except Exception as e: log.error(f"L·ªói yt-dlp khi T√åM KI·∫æM '{query}': {e}", exc_info=True); return []
    @classmethod
    async def from_url_and_download(cls, url: str, requester: discord.Member | discord.User):
        loop = asyncio.get_running_loop(); ytdl = yt_dlp.YoutubeDL(YTDL_DOWNLOAD_OPTIONS)
        partial = functools.partial(ytdl.extract_info, url, download=True)
        try:
            data = await loop.run_in_executor(None, partial);
            if not data: return None
            if 'entries' in data: data = data['entries'][0]
            song = cls(data, requester); song.filepath = ytdl.prepare_filename(data); return song
        except Exception as e: log.error(f"L·ªói yt-dlp khi T·∫¢I V·ªÄ '{url}': {e}", exc_info=True); return None

class SearchView(discord.ui.View):
    """Giao di·ªán cho k·∫øt qu·∫£ t√¨m ki·∫øm."""
    def __init__(self, *, music_cog, ctx: AnyContext, results: list[Song]):
        super().__init__(timeout=180.0);self.music_cog=music_cog;self.ctx=ctx;self.requester=ctx.author if isinstance(ctx,commands.Context)else ctx.user;self.results=results;self.current_page=1;self.songs_per_page=5;self.total_pages=math.ceil(len(self.results)/self.songs_per_page);self.message=None;self.update_components()
    async def on_timeout(self):
        if self.message:
            try:await self.message.edit(content="H·∫øt th·ªùi gian t√¨m ki·∫øm.",embed=None,view=None)
            except discord.NotFound:pass
        self.stop()
    async def start(self):
        embed=self.create_page_embed()
        if isinstance(self.ctx, discord.Interaction):
            if self.ctx.response.is_done():self.message=await self.ctx.followup.send(embed=embed,view=self,ephemeral=True)
            else:await self.ctx.response.send_message(embed=embed,view=self,ephemeral=True);self.message=await self.ctx.original_response()
        else:self.message=await self.ctx.send(embed=embed,view=self)
    def update_components(self):self.prev_page_button.disabled=self.current_page==1;self.next_page_button.disabled=self.current_page>=self.total_pages;self.clear_items();self.add_item(self.create_select_menu());self.add_item(self.prev_page_button);self.add_item(self.next_page_button);self.add_item(self.cancel_button)
    def create_page_embed(self)->discord.Embed:start_index=(self.current_page-1)*self.songs_per_page;end_index=start_index+self.songs_per_page;page_results=self.results[start_index:end_index];description="".join(f"`{i+1}.` [{s.title}]({s.url})\n`{s.uploader or 'N/A'} - {s.format_duration()}`\n\n"for i,s in enumerate(page_results,start=start_index));embed=discord.Embed(title=f"üîé K·∫øt qu·∫£ t√¨m ki·∫øm (Trang {self.current_page}/{self.total_pages})",description=description,color=discord.Color.blue());embed.set_footer(text=f"Y√™u c·∫ßu b·ªüi {self.requester.display_name}",icon_url=self.requester.display_avatar.url);return embed
    def create_select_menu(self)->discord.ui.Select:start_index=(self.current_page-1)*self.songs_per_page;end_index=start_index+self.songs_per_page;options=[discord.SelectOption(label=f"{i+1}. {s.title[:80]}",value=str(i))for i,s in enumerate(self.results[start_index:end_index],start=start_index)];select=discord.ui.Select(placeholder="Ch·ªçn m·ªôt b√†i h√°t ƒë·ªÉ th√™m...",options=options,custom_id="search_select_menu");select.callback=self.select_callback;return select
    async def select_callback(self,interaction:discord.Interaction):
        if interaction.user.id!=self.requester.id:return await interaction.response.send_message("B·∫°n kh√¥ng ph·∫£i ng∆∞·ªùi y√™u c·∫ßu!",ephemeral=True)
        await interaction.response.defer();await self.message.edit(content="‚è≥ ƒêang t·∫£i b√†i h√°t b·∫°n ch·ªçn...",embed=None,view=None)
        selected_song=await Song.from_url_and_download(self.results[int(interaction.data["values"][0])].url,self.requester)
        if selected_song:
            state=self.music_cog.get_guild_state(interaction.guild_id)
            await state.queue.put(selected_song)
            if state.player_task is None or state.player_task.done():
                state.player_task=asyncio.create_task(state.player_loop())
            await self.message.edit(content=f"‚úÖ ƒê√£ th√™m **{selected_song.title}** v√†o h√†ng ƒë·ª£i.")
        else:
            await self.message.edit(content=f"‚ùå R·∫•t ti·∫øc, ƒë√£ c√≥ l·ªói khi t·∫£i v·ªÅ b√†i h√°t n√†y.")
        self.stop()
    @discord.ui.button(label="Tr∆∞·ªõc",style=discord.ButtonStyle.secondary,emoji="‚¨ÖÔ∏è")
    async def prev_page_button(self,interaction:discord.Interaction,button:discord.ui.Button):
        if interaction.user.id!=self.requester.id:return await interaction.response.send_message("B·∫°n kh√¥ng ph·∫£i ng∆∞·ªùi y√™u c·∫ßu!",ephemeral=True)
        self.current_page-=1;self.update_components();await interaction.response.edit_message(embed=self.create_page_embed(),view=self)
    @discord.ui.button(label="Sau",style=discord.ButtonStyle.secondary,emoji="‚û°Ô∏è")
    async def next_page_button(self,interaction:discord.Interaction,button:discord.ui.Button):
        if interaction.user.id!=self.requester.id:return await interaction.response.send_message("B·∫°n kh√¥ng ph·∫£i ng∆∞·ªùi y√™u c·∫ßu!",ephemeral=True)
        self.current_page+=1;self.update_components();await interaction.response.edit_message(embed=self.create_page_embed(),view=self)
    @discord.ui.button(label="H·ªßy",style=discord.ButtonStyle.danger,emoji="‚èπÔ∏è")
    async def cancel_button(self,interaction:discord.Interaction,button:discord.ui.Button):
        if interaction.user.id!=self.requester.id:return await interaction.response.send_message("B·∫°n kh√¥ng ph·∫£i ng∆∞·ªùi y√™u c·∫ßu!",ephemeral=True)
        await self.message.edit(content="ƒê√£ h·ªßy t√¨m ki·∫øm.",embed=None,view=None);self.stop()

class GuildState:
    """Qu·∫£n l√Ω tr·∫°ng th√°i c·ªßa t·ª´ng server."""
    def __init__(self, bot: commands.Bot, guild_id: int):self.bot=bot;self.guild_id=guild_id;self.queue=asyncio.Queue[Song]();self.voice_client:discord.VoiceClient|None=None;self.now_playing_message:discord.Message|None=None;self.current_song:Song|None=None;self.loop_mode=LoopMode.OFF;self.player_task:asyncio.Task|None=None;self.last_ctx:AnyContext|None=None;self.song_finished_event=asyncio.Event();self.volume=0.5
    async def player_loop(self):
        await self.bot.wait_until_ready()
        while True:
            try:
                previous_song=self.current_song
                if previous_song:
                    if self.loop_mode==LoopMode.SONG:log.info(f"Guild {self.guild_id}: L·∫∑p l·∫°i b√†i h√°t '{previous_song.title}'.")
                    elif self.loop_mode==LoopMode.QUEUE:log.info(f"Guild {self.guild_id}: Th√™m '{previous_song.title}' v√†o cu·ªëi h√†ng ƒë·ª£i l·∫∑p l·∫°i.");await self.queue.put(previous_song)
                    else:previous_song.cleanup()
                if self.loop_mode!=LoopMode.SONG or not self.current_song:self.current_song=await asyncio.wait_for(self.queue.get(),timeout=300)
                log.info(f"Guild {self.guild_id}: L·∫•y b√†i h√°t '{self.current_song.title}' t·ª´ h√†ng ƒë·ª£i.")
                await self.update_now_playing_message(new_song=True)
                source=discord.PCMVolumeTransformer(discord.FFmpegPCMAudio(self.current_song.filepath,**FFMPEG_OPTIONS),volume=self.volume)
                self.song_finished_event.clear()
                self.voice_client.play(source,after=lambda e:self.bot.loop.call_soon_threadsafe(self.song_finished_event.set))
                await self.song_finished_event.wait()
                log.info(f"Guild {self.guild_id}: S·ª± ki·ªán k·∫øt th√∫c b√†i h√°t '{self.current_song.title}' ƒë∆∞·ª£c k√≠ch ho·∫°t.")
            except asyncio.TimeoutError:
                log.info(f"Guild {self.guild_id} kh√¥ng ho·∫°t ƒë·ªông trong 5 ph√∫t, b·∫Øt ƒë·∫ßu d·ªçn d·∫πp.")
                if self.last_ctx and self.last_ctx.channel:
                    try: await self.last_ctx.channel.send("üò¥ ƒê√£ t·ª± ƒë·ªông ng·∫Øt k·∫øt n·ªëi do kh√¥ng ho·∫°t ƒë·ªông.")
                    except discord.Forbidden: pass
                await self.cleanup();break
            except asyncio.CancelledError:log.info(f"Player loop cho guild {self.guild_id} ƒë√£ b·ªã h·ªßy.");break
            except Exception as e:
                log.error(f"L·ªói nghi√™m tr·ªçng trong player loop c·ªßa guild {self.guild_id}:",exc_info=e)
                if self.last_ctx and self.last_ctx.channel:
                    try: await self.last_ctx.channel.send(f"ü§ñ G·∫∑p l·ªói nghi√™m tr·ªçng, Miku c·∫ßn kh·ªüi ƒë·ªông l·∫°i tr√¨nh ph√°t nh·∫°c. L·ªói: `{e}`")
                    except discord.Forbidden: pass
                await self.cleanup();break
    async def update_now_playing_message(self,new_song=False):
        if not self.last_ctx:return
        if not self.current_song and self.now_playing_message:
            try:await self.now_playing_message.delete()
            except discord.NotFound:pass
            self.now_playing_message=None;return
        if not self.current_song:return
        embed=self.create_now_playing_embed();view=self.create_control_view()
        if new_song and self.now_playing_message:
            try:await self.now_playing_message.delete()
            except discord.NotFound:pass
            self.now_playing_message=None
        if self.now_playing_message:
            try:await self.now_playing_message.edit(embed=embed,view=view);return
            except discord.NotFound:self.now_playing_message=None
        if not self.now_playing_message:
            try:self.now_playing_message=await self.last_ctx.channel.send(embed=embed,view=view)
            except(discord.Forbidden,discord.HTTPException)as e:log.warning(f"Kh√¥ng th·ªÉ g·ª≠i/c·∫≠p nh·∫≠t tin nh·∫Øn Now Playing: {e}");self.now_playing_message=None
    def create_now_playing_embed(self)->discord.Embed:song=self.current_song;embed=discord.Embed(title=song.title,url=song.url,color=0x39d0d6);embed.set_author(name=f"ƒêang ph√°t üéµ (√Çm l∆∞·ª£ng: {int(self.volume*100)}%)",icon_url=self.bot.user.display_avatar.url);embed.set_thumbnail(url=song.thumbnail);embed.add_field(name="Ngh·ªá sƒ©",value=song.uploader or 'N/A',inline=True);embed.add_field(name="Th·ªùi l∆∞·ª£ng",value=song.format_duration(),inline=True);embed.add_field(name="Y√™u c·∫ßu b·ªüi",value=song.requester.mention,inline=True);loop_status={LoopMode.OFF:"T·∫Øt",LoopMode.SONG:"üîÅ B√†i h√°t",LoopMode.QUEUE:"üîÅ H√†ng ƒë·ª£i"};next_song_title="Kh√¥ng c√≥" if self.queue.empty()else self.queue._queue[0].title[:50]+"...";total_songs=self.queue.qsize()+(1 if self.current_song else 0);embed.set_footer(text=f"Ti·∫øp theo: {next_song_title} | L·∫∑p: {loop_status[self.loop_mode]} | T·ªïng c·ªông: {total_songs} b√†i");return embed
    def create_control_view(self)->discord.ui.View:view=discord.ui.View(timeout=None);pause_resume_btn=discord.ui.Button(emoji="‚èØÔ∏è",style=discord.ButtonStyle.secondary,custom_id=f"ctrl_pause_{self.guild_id}");skip_btn=discord.ui.Button(emoji="‚è≠Ô∏è",style=discord.ButtonStyle.secondary,custom_id=f"ctrl_skip_{self.guild_id}");stop_btn=discord.ui.Button(emoji="‚èπÔ∏è",style=discord.ButtonStyle.danger,custom_id=f"ctrl_stop_{self.guild_id}");loop_btn=discord.ui.Button(emoji="üîÅ",style=discord.ButtonStyle.secondary,custom_id=f"ctrl_loop_{self.guild_id}");queue_btn=discord.ui.Button(label="H√†ng ƒë·ª£i",emoji="üìú",style=discord.ButtonStyle.primary,custom_id=f"ctrl_queue_{self.guild_id}");pause_resume_btn.callback=self.pause_resume_callback;skip_btn.callback=self.skip_callback;stop_btn.callback=self.stop_callback;loop_btn.callback=self.loop_callback;queue_btn.callback=self.queue_callback;view.add_item(pause_resume_btn);view.add_item(skip_btn);view.add_item(stop_btn);view.add_item(loop_btn);view.add_item(queue_btn);return view
    async def pause_resume_callback(self,interaction:discord.Interaction):
        if self.voice_client.is_paused():self.voice_client.resume();await interaction.response.send_message("‚ñ∂Ô∏è ƒê√£ ti·∫øp t·ª•c ph√°t.",ephemeral=True)
        else:self.voice_client.pause();await interaction.response.send_message("‚è∏Ô∏è ƒê√£ t·∫°m d·ª´ng.",ephemeral=True)
    async def skip_callback(self,interaction:discord.Interaction):
        if self.voice_client and(self.voice_client.is_playing()or self.voice_client.is_paused()):self.voice_client.stop();await interaction.response.send_message("‚è≠Ô∏è ƒê√£ chuy·ªÉn b√†i.",ephemeral=True)
        else:await interaction.response.send_message("Kh√¥ng c√≥ b√†i n√†o ƒëang ph√°t ƒë·ªÉ chuy·ªÉn.",ephemeral=True)
    async def stop_callback(self,interaction:discord.Interaction):await interaction.response.send_message("‚èπÔ∏è ƒêang d·ª´ng ph√°t nh·∫°c v√† d·ªçn d·∫πp h√†ng ƒë·ª£i...",ephemeral=True);await self.cleanup()
    async def loop_callback(self,interaction:discord.Interaction):self.loop_mode=LoopMode((self.loop_mode.value+1)%3);log.info(f"Guild {self.guild_id} ƒë√£ ƒë·ªïi ch·∫ø ƒë·ªô l·∫∑p th√†nh {self.loop_mode.name}");mode_text={LoopMode.OFF:"T·∫Øt l·∫∑p.",LoopMode.SONG:"üîÅ L·∫∑p l·∫°i b√†i h√°t hi·ªán t·∫°i.",LoopMode.QUEUE:"üîÅ L·∫∑p l·∫°i to√†n b·ªô h√†ng ƒë·ª£i."};await interaction.response.send_message(mode_text[self.loop_mode],ephemeral=True);await self.update_now_playing_message()
    async def queue_callback(self,interaction:discord.Interaction):
        embed = self._create_queue_embed()
        if not embed: return await interaction.response.send_message("H√†ng ƒë·ª£i tr·ªëng!", ephemeral=True)
        await interaction.response.send_message(embed=embed,ephemeral=True)
    def _create_queue_embed(self) -> discord.Embed | None:
        if self.queue.empty() and not self.current_song: return None
        embed = discord.Embed(title="üìú H√†ng ƒë·ª£i b√†i h√°t", color=discord.Color.gold())
        if self.current_song: embed.add_field(name="‚ñ∂Ô∏è ƒêang ph√°t", value=f"[{self.current_song.title}]({self.current_song.url}) - Y/c b·ªüi {self.current_song.requester.mention}", inline=False)
        queue_list = list(self.queue._queue)
        if queue_list:
            queue_text = "\n".join([f"`{i+1}.` [{song.title}]({song.url})" for i, song in enumerate(queue_list[:10])])
            if len(queue_list) > 10: queue_text += f"\n... v√† {len(queue_list) - 10} b√†i h√°t kh√°c."
            embed.add_field(name="üé∂ Ti·∫øp theo", value=queue_text, inline=False)
        embed.set_footer(text=f"T·ªïng c·ªông: {len(queue_list) + (1 if self.current_song else 0)} b√†i h√°t"); return embed
    async def cleanup(self):
        log.info(f"B·∫Øt ƒë·∫ßu cleanup cho guild {self.guild_id}");self.bot.dispatch("session_end",self.guild_id)
        if self.player_task:self.player_task.cancel()
        if self.current_song:self.current_song.cleanup()
        while not self.queue.empty():
            try:song=self.queue.get_nowait();song.cleanup()
            except asyncio.QueueEmpty:break
        if self.voice_client:await self.voice_client.disconnect(force=True);log.info(f"ƒê√£ ng·∫Øt k·∫øt n·ªëi voice client kh·ªèi guild {self.guild_id}")
        if self.now_playing_message:
            try:await self.now_playing_message.delete()
            except discord.NotFound:pass

# === COG GENERAL ===
class General(commands.Cog):
    """Ch·ª©a c√°c l·ªánh chung v√† x·ª≠ l√Ω s·ª± ki·ªán."""
    def __init__(self, bot: commands.Bot):
        self.bot = bot
    
    @commands.Cog.listener()
    async def on_guild_join(self, guild: discord.Guild):
        """T·ª± ƒë·ªông ƒë·ªìng b·ªô l·ªánh khi bot tham gia server m·ªõi."""
        log.info(f"ƒê√£ tham gia server m·ªõi: {guild.name} ({guild.id}). B·∫Øt ƒë·∫ßu ƒë·ªìng b·ªô l·ªánh...")
        try:
            await self.bot.tree.sync(guild=guild)
            log.info(f"ƒê√£ ƒë·ªìng b·ªô l·ªánh th√†nh c√¥ng cho {guild.name}.")
        except Exception as e:
            log.error(f"L·ªói khi ƒë·ªìng b·ªô l·ªánh cho server m·ªõi {guild.name}:", exc_info=e)

    def _create_help_embed(self) -> discord.Embed:
        prefix = self.bot.command_prefix
        embed = discord.Embed(
            title="‚ú® Menu tr·ª£ gi√∫p c·ªßa Miku ‚ú®",
            description="Miku s·∫µn s√†ng gi√∫p b·∫°n th∆∞·ªüng th·ª©c √¢m nh·∫°c tuy·ªát v·ªùi nh·∫•t! (¬¥‚Ä¢ œâ ‚Ä¢`) ‚ô°",
            color=0x39d0d6 # Miku's color
        )
        embed.set_author(name=self.bot.user.name, icon_url=self.bot.user.display_avatar.url)
        embed.set_thumbnail(url="https://cdn.discordapp.com/attachments/1319215782089199616/1384577698315370587/6482863b5c8c3328433411f2-anime-hatsune-miku-plush-toy-series-snow.gif?ex=6852eff7&is=68519e77&hm=c89ddf3b2d3d2801118f537a45a6b67fcdd77cdb5c28d17ec6df791a040bac23&")

        # --- L·ªánh √Çm Nh·∫°c ƒë∆∞·ª£c chia nh·ªè ---
        
        embed.add_field(
            name="üéß L·ªánh √Çm Nh·∫°c (C∆° b·∫£n)",
            value=f"""
            `play <t√™n/url>`: Ph√°t ho·∫∑c t√¨m ki·∫øm b√†i h√°t.
            `pause`: T·∫°m d·ª´ng/ti·∫øp t·ª•c ph√°t.
            `skip`: B·ªè qua b√†i h√°t hi·ªán t·∫°i.
            `stop`: D·ª´ng nh·∫°c v√† r·ªùi k√™nh.
            """,
            inline=False
        )
        
        embed.add_field(
            name="üìú L·ªánh H√†ng ƒë·ª£i",
            value=f"""
            `queue`: Xem h√†ng ƒë·ª£i hi·ªán t·∫°i.
            `shuffle`: X√°o tr·ªôn th·ª© t·ª± h√†ng ƒë·ª£i.
            `remove <s·ªë>`: X√≥a b√†i h√°t kh·ªèi h√†ng ƒë·ª£i.
            `clear`: X√≥a s·∫°ch h√†ng ƒë·ª£i.
            """,
            inline=False
        )

        embed.add_field(
            name="‚öôÔ∏è L·ªánh Ti·ªán √≠ch",
            value=f"""
            `nowplaying`: Hi·ªÉn th·ªã l·∫°i b·∫£ng ƒëi·ªÅu khi·ªÉn.
            `volume <0-200>`: Ch·ªânh √¢m l∆∞·ª£ng.
            `seek <th·ªùi gian>`: Tua nh·∫°c (vd: `1:23`).
            `lyrics`: T√¨m l·ªùi b√†i h√°t ƒëang ph√°t.
            """,
            inline=False
        )

        # --- L·ªánh Chung ---
        general_commands_text = f"""
        `help`: Hi·ªÉn th·ªã b·∫£ng tr·ª£ gi√∫p n√†y.
        `ping`: Ki·ªÉm tra ƒë·ªô tr·ªÖ c·ªßa Miku.
        """
        embed.add_field(name="‚ú® L·ªánh Chung", value=general_commands_text, inline=False)
        
        # --- Footer ---
        embed.set_footer(
            text=f"S·ª≠ d·ª•ng l·ªánh v·ªõi / (slash) ho·∫∑c {prefix} (prefix) ‚Ä¢ HatsuneMikuv2 | Project Galaxy by imnhyneko.dev",
            icon_url="https://avatars.githubusercontent.com/u/119964287?v=4"
        )
        return embed
    
    @commands.command(name="help", aliases=['h'])
    async def prefix_help(self, ctx: commands.Context):
        embed = self._create_help_embed()
        await ctx.send(embed=embed)
    @commands.command(name="ping")
    async def prefix_ping(self, ctx: commands.Context):
        latency = round(self.bot.latency * 1000)
        await ctx.send(f"Pong! üèì ƒê·ªô tr·ªÖ c·ªßa Miku l√† `{latency}ms`. Nhanh nh∆∞ m·ªôt n·ªët nh·∫°c! üé∂")
    
    @app_commands.command(name="help", description="Hi·ªÉn th·ªã menu tr·ª£ gi√∫p c·ªßa Miku.")
    async def slash_help(self, interaction: discord.Interaction):
        embed = self._create_help_embed()
        await interaction.response.send_message(embed=embed, ephemeral=True)
    @app_commands.command(name="ping", description="Ki·ªÉm tra ƒë·ªô tr·ªÖ c·ªßa Miku.")
    async def slash_ping(self, interaction: discord.Interaction):
        latency = round(self.bot.latency * 1000)
        await interaction.response.send_message(f"Pong! üèì ƒê·ªô tr·ªÖ c·ªßa Miku l√† `{latency}ms`. Nhanh nh∆∞ m·ªôt n·ªët nh·∫°c! üé∂", ephemeral=True)

# === COG MUSIC ===
class Music(commands.Cog):
    """Ch·ª©a c√°c l·ªánh li√™n quan ƒë·∫øn √¢m nh·∫°c."""
    music_group = app_commands.Group(name="music", description="C√°c l·ªánh li√™n quan ƒë·∫øn ph√°t nh·∫°c.")

    def __init__(self, bot: commands.Bot):
        self.bot = bot; self.states = {}; self.session = aiohttp.ClientSession()
    def cog_unload(self): self.bot.loop.create_task(self.session.close())
    def get_guild_state(self, guild_id: int) -> GuildState:
        if guild_id not in self.states: self.states[guild_id] = GuildState(self.bot, guild_id)
        return self.states[guild_id]
    @commands.Cog.listener()
    async def on_session_end(self, guild_id: int):
        if guild_id in self.states: log.info(f"X√≥a GuildState c·ªßa guild {guild_id} kh·ªèi b·ªô nh·ªõ."); del self.states[guild_id]
    @commands.Cog.listener()
    async def on_voice_state_update(self, member, before, after):
        if not member.guild.voice_client or member.bot: return
        vc = member.guild.voice_client
        if len(vc.channel.members) == 1:
            log.info(f"Bot ·ªü m·ªôt m√¨nh trong k√™nh {vc.channel.name}, s·∫Ω t·ª± ng·∫Øt k·∫øt n·ªëi sau 60s.")
            await asyncio.sleep(60)
            if vc and len(vc.channel.members) == 1:
                log.info(f"V·∫´n ch·ªâ c√≥ m·ªôt m√¨nh, ƒëang ng·∫Øt k·∫øt n·ªëi...")
                state = self.get_guild_state(member.guild.id)
                if state.last_ctx:
                    try: await state.last_ctx.channel.send("üëã T·∫°m bi·ªát! Miku s·∫Ω r·ªùi ƒëi v√¨ kh√¥ng c√≥ ai nghe c√πng.")
                    except discord.Forbidden: pass
                await state.cleanup()
    async def _send_response(self, ctx: AnyContext, *args, **kwargs):
        ephemeral = kwargs.get('ephemeral', False)
        if isinstance(ctx, discord.Interaction):
            if ctx.response.is_done(): await ctx.followup.send(*args, **kwargs)
            else: await ctx.response.send_message(*args, **kwargs)
        else: kwargs.pop('ephemeral', None); await ctx.send(*args, **kwargs)
    async def _play_logic(self, ctx: AnyContext, query: Optional[str]):
        state = self.get_guild_state(ctx.guild.id); state.last_ctx = ctx; author = ctx.author if isinstance(ctx, commands.Context) else ctx.user
        if not author.voice or not author.voice.channel: return await self._send_response(ctx, "B·∫°n ph·∫£i ·ªü trong m·ªôt k√™nh tho·∫°i ƒë·ªÉ d√πng l·ªánh n√†y!", ephemeral=True)
        if not query:
            if state.voice_client and state.voice_client.is_paused(): state.voice_client.resume(); await self._send_response(ctx, "‚ñ∂Ô∏è ƒê√£ ti·∫øp t·ª•c ph√°t nh·∫°c.", ephemeral=True)
            elif state.voice_client and state.voice_client.is_playing(): state.voice_client.pause(); await self._send_response(ctx, "‚èØÔ∏è ƒê√£ t·∫°m d·ª´ng nh·∫°c.", ephemeral=True)
            else: await self._send_response(ctx, "Kh√¥ng c√≥ nh·∫°c n√†o ƒëang ph√°t ho·∫∑c t·∫°m d·ª´ng.", ephemeral=True)
            return
        if isinstance(ctx, discord.Interaction): await ctx.response.defer(ephemeral=False)
        else: await ctx.message.add_reaction("‚è≥")
        if not ctx.guild.voice_client: state.voice_client = await author.voice.channel.connect()
        else: await ctx.guild.voice_client.move_to(author.voice.channel); state.voice_client = ctx.guild.voice_client
        if query.startswith(('http://', 'https://')):
            song = await Song.from_url_and_download(query, author)
            if song:
                await state.queue.put(song); response_message = f"‚úÖ ƒê√£ th√™m **{song.title}** v√†o h√†ng ƒë·ª£i."
                if isinstance(ctx, discord.Interaction) and ctx.response.is_done(): await ctx.followup.send(response_message)
                else: await self._send_response(ctx, response_message)
                if state.player_task is None or state.player_task.done(): state.player_task = asyncio.create_task(state.player_loop())
            else: await self._send_response(ctx, f"‚ùå Kh√¥ng th·ªÉ t·∫£i v·ªÅ t·ª´ URL: `{query}`")
        else:
            search_results = await Song.search_only(query, author)
            if not search_results: await self._send_response(ctx, f"‚ùì Kh√¥ng t√¨m th·∫•y k·∫øt qu·∫£ n√†o cho: `{query}`")
            else: search_view = SearchView(music_cog=self, ctx=ctx, results=search_results); await search_view.start()
        if isinstance(ctx, commands.Context): await ctx.message.remove_reaction("‚è≥", self.bot.user)
    async def _stop_logic(self, ctx: AnyContext):
        state = self.get_guild_state(ctx.guild.id)
        if state.voice_client: await self._send_response(ctx, "‚èπÔ∏è ƒê√£ d·ª´ng ph√°t nh·∫°c v√† d·ªçn d·∫πp h√†ng ƒë·ª£i."); await state.cleanup()
        else: await self._send_response(ctx, "Miku kh√¥ng ·ªü trong k√™nh tho·∫°i n√†o c·∫£.", ephemeral=True)
    async def _skip_logic(self, ctx: AnyContext):
        state = self.get_guild_state(ctx.guild.id)
        if state.voice_client and (state.voice_client.is_playing() or state.voice_client.is_paused()): state.voice_client.stop(); await self._send_response(ctx, "‚è≠Ô∏è ƒê√£ chuy·ªÉn b√†i.", ephemeral=True)
        else: await self._send_response(ctx, "Kh√¥ng c√≥ b√†i n√†o ƒëang ph√°t ƒë·ªÉ chuy·ªÉn.", ephemeral=True)
    async def _pause_logic(self, ctx: AnyContext):
        state = self.get_guild_state(ctx.guild.id)
        if state.voice_client and state.voice_client.is_playing(): state.voice_client.pause(); await self._send_response(ctx, "‚è∏Ô∏è ƒê√£ t·∫°m d·ª´ng nh·∫°c.", ephemeral=True)
        elif state.voice_client and state.voice_client.is_paused(): state.voice_client.resume(); await self._send_response(ctx, "‚ñ∂Ô∏è ƒê√£ ti·∫øp t·ª•c ph√°t nh·∫°c.", ephemeral=True)
        else: await self._send_response(ctx, "Kh√¥ng c√≥ nh·∫°c n√†o ƒëang ph√°t ƒë·ªÉ t·∫°m d·ª´ng/ti·∫øp t·ª•c.", ephemeral=True)
    async def _volume_logic(self, ctx: AnyContext, value: int):
        state = self.get_guild_state(ctx.guild.id)
        if not state.voice_client: return await self._send_response(ctx, "Miku ch∆∞a v√†o k√™nh tho·∫°i.", ephemeral=True)
        if not 0 <= value <= 200: return await self._send_response(ctx, "√Çm l∆∞·ª£ng ph·∫£i trong kho·∫£ng t·ª´ 0 ƒë·∫øn 200.", ephemeral=True)
        state.volume = value / 100
        if state.voice_client.source: state.voice_client.source.volume = state.volume
        await self._send_response(ctx, f"üîä ƒê√£ ƒë·∫∑t √¢m l∆∞·ª£ng th√†nh **{value}%**."); await state.update_now_playing_message()
    async def _seek_logic(self, ctx: AnyContext, timestamp: str):
        state = self.get_guild_state(ctx.guild.id);
        if not state.voice_client or not state.current_song:return await self._send_response(ctx,"Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t ƒë·ªÉ tua.",ephemeral=True)
        match=re.match(r'(?:(\d+):)?(\d+)',timestamp)
        if not match:
            try:seconds=int(timestamp)
            except ValueError:return await self._send_response(ctx,"ƒê·ªãnh d·∫°ng th·ªùi gian kh√¥ng h·ª£p l·ªá. H√£y d√πng `ph√∫t:gi√¢y` ho·∫∑c `gi√¢y`.",ephemeral=True)
        else:minutes=int(match.group(1)or 0);seconds=int(match.group(2));seconds+=minutes*60
        if seconds>=state.current_song.duration:return await self._send_response(ctx,"Kh√¥ng th·ªÉ tua v∆∞·ª£t qu√° th·ªùi l∆∞·ª£ng b√†i h√°t.",ephemeral=True)
        ffmpeg_options_seek=FFMPEG_OPTIONS.copy();ffmpeg_options_seek['before_options']=f"-ss {seconds}";state.voice_client.stop();new_source=discord.PCMVolumeTransformer(discord.FFmpegPCMAudio(state.current_song.filepath,**ffmpeg_options_seek),volume=state.volume);state.voice_client.play(new_source,after=lambda e:self.bot.loop.call_soon_threadsafe(state.song_finished_event.set));await self._send_response(ctx,f"‚è© ƒê√£ tua ƒë·∫øn `{seconds}` gi√¢y.")
    async def _lyrics_logic(self,ctx:AnyContext):
        state=self.get_guild_state(ctx.guild.id)
        if not state.current_song:return await self._send_response(ctx,"Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t.",ephemeral=True)
        if isinstance(ctx,discord.Interaction):await ctx.response.defer(ephemeral=True)
        else:await ctx.message.add_reaction("üîç")
        title_search=re.sub(r'\(.*\)|\[.*\]|ft\..*','',state.current_song.title).strip();uploader_search=re.sub(r' - Topic','',state.current_song.uploader).strip()
        async with self.session.get(f"https://api.lyrics.ovh/v1/{uploader_search}/{title_search}")as resp:
            if resp.status!=200:msg=f"R·∫•t ti·∫øc, Miku kh√¥ng t√¨m th·∫•y l·ªùi b√†i h√°t cho `{state.current_song.title}`. (¬¥-œâ-`)"
            else:
                data=await resp.json();lyrics=data.get('lyrics')
                if not lyrics:msg=f"R·∫•t ti·∫øc, Miku kh√¥ng t√¨m th·∫•y l·ªùi b√†i h√°t cho `{state.current_song.title}`. (¬¥-œâ-`)"
                else:
                    embed=discord.Embed(title=f"üé§ L·ªùi b√†i h√°t: {state.current_song.title}",color=0x39d0d6);embed.set_thumbnail(url=state.current_song.thumbnail)
                    if len(lyrics)>4096:lyrics=lyrics[:4090]+"\n..."
                    embed.description=lyrics;await self._send_response(ctx,embed=embed)
                    if isinstance(ctx,commands.Context):await ctx.message.remove_reaction("üîç",self.bot.user)
                    return
            await self._send_response(ctx,msg,ephemeral=True)
            if isinstance(ctx,commands.Context):await ctx.message.remove_reaction("üîç",self.bot.user)
    
    # --- PREFIX COMMANDS ---
    @commands.command(name="play", aliases=['p'])
    async def prefix_play(self, ctx: commands.Context, *, query: str = None): await self._play_logic(ctx, query)
    @commands.command(name="pause", aliases=['resume'])
    async def prefix_pause(self, ctx: commands.Context): await self._pause_logic(ctx)
    @commands.command(name="stop", aliases=['leave', 'disconnect'])
    async def prefix_stop(self, ctx: commands.Context): await self._stop_logic(ctx)
    @commands.command(name="skip", aliases=['s', 'fs'])
    async def prefix_skip(self, ctx: commands.Context): await self._skip_logic(ctx)
    @commands.command(name="queue", aliases=['q'])
    async def prefix_queue(self, ctx: commands.Context):
        state = self.get_guild_state(ctx.guild.id); embed = state._create_queue_embed()
        if not embed: await ctx.send("H√†ng ƒë·ª£i tr·ªëng!"); return
        await ctx.send(embed=embed)
    @commands.command(name="nowplaying", aliases=['np'])
    async def prefix_nowplaying(self, ctx: commands.Context):
        state = self.get_guild_state(ctx.guild.id); state.last_ctx = ctx; await state.update_now_playing_message(new_song=True)
    @commands.command(name="volume", aliases=['vol'])
    async def prefix_volume(self, ctx: commands.Context, value: int): await self._volume_logic(ctx, value)
    @commands.command(name="shuffle")
    async def prefix_shuffle(self, ctx: commands.Context):
        state = self.get_guild_state(ctx.guild.id)
        if state.queue.qsize()<2:return await ctx.send("Kh√¥ng ƒë·ªß b√†i h√°t ƒë·ªÉ x√°o tr·ªôn.")
        queue_list=list(state.queue._queue);random.shuffle(queue_list)
        while not state.queue.empty():state.queue.get_nowait()
        for song in queue_list:await state.queue.put(song)
        await ctx.send("üîÄ ƒê√£ x√°o tr·ªôn h√†ng ƒë·ª£i!")
    @commands.command(name="remove")
    async def prefix_remove(self, ctx: commands.Context, index: int):
        state = self.get_guild_state(ctx.guild.id)
        if index <= 0 or index > state.queue.qsize():return await ctx.send("S·ªë th·ª© t·ª± kh√¥ng h·ª£p l·ªá.")
        queue_list=list(state.queue._queue);removed_song=queue_list.pop(index-1);removed_song.cleanup()
        while not state.queue.empty():state.queue.get_nowait()
        for song in queue_list:await state.queue.put(song)
        await ctx.send(f"üóëÔ∏è ƒê√£ x√≥a **{removed_song.title}** kh·ªèi h√†ng ƒë·ª£i.")
    @commands.command(name="clear")
    async def prefix_clear(self, ctx: commands.Context):
        state = self.get_guild_state(ctx.guild.id); count = 0
        while not state.queue.empty():
            try:song=state.queue.get_nowait();song.cleanup();count+=1
            except asyncio.QueueEmpty:break
        await ctx.send(f"üí• ƒê√£ x√≥a s·∫°ch {count} b√†i h√°t kh·ªèi h√†ng ƒë·ª£i.")
    @commands.command(name="seek")
    async def prefix_seek(self, ctx: commands.Context, timestamp: str): await self._seek_logic(ctx, timestamp)
    @commands.command(name="lyrics", aliases=['ly'])
    async def prefix_lyrics(self, ctx: commands.Context): await self._lyrics_logic(ctx)
    
    # --- SLASH COMMANDS ---
    @music_group.command(name="play", description="Ph√°t nh·∫°c, th√™m v√†o h√†ng ƒë·ª£i, ho·∫∑c t·∫°m d·ª´ng/ti·∫øp t·ª•c.")
    @app_commands.describe(query="T√™n b√†i h√°t, URL, ho·∫∑c ƒë·ªÉ tr·ªëng ƒë·ªÉ t·∫°m d·ª´ng/ti·∫øp t·ª•c.")
    async def slash_play(self, interaction: discord.Interaction, query: Optional[str] = None): await self._play_logic(interaction, query)
    @music_group.command(name="pause", description="T·∫°m d·ª´ng ho·∫∑c ti·∫øp t·ª•c ph√°t b√†i h√°t hi·ªán t·∫°i.")
    async def slash_pause(self, interaction: discord.Interaction): await self._pause_logic(interaction)
    @music_group.command(name="stop", description="D·ª´ng ph√°t nh·∫°c v√† ng·∫Øt k·∫øt n·ªëi.")
    async def slash_stop(self, interaction: discord.Interaction): await self._stop_logic(interaction)
    @music_group.command(name="skip", description="B·ªè qua b√†i h√°t hi·ªán t·∫°i.")
    async def slash_skip(self, interaction: discord.Interaction): await self._skip_logic(interaction)
    @music_group.command(name="queue", description="Hi·ªÉn th·ªã h√†ng ƒë·ª£i b√†i h√°t.")
    async def slash_queue(self, interaction: discord.Interaction):
        state = self.get_guild_state(interaction.guild.id); state.last_ctx = interaction; await state.queue_callback(interaction)
    @music_group.command(name="nowplaying", description="Hi·ªÉn th·ªã l·∫°i b·∫£ng ƒëi·ªÅu khi·ªÉn nh·∫°c.")
    async def slash_nowplaying(self, interaction: discord.Interaction):
        state = self.get_guild_state(interaction.guild.id); state.last_ctx = interaction; await state.update_now_playing_message(new_song=True); await interaction.response.send_message("ƒê√£ hi·ªÉn th·ªã l·∫°i b·∫£ng ƒëi·ªÅu khi·ªÉn.", ephemeral=True)
    @music_group.command(name="volume", description="ƒêi·ªÅu ch·ªânh √¢m l∆∞·ª£ng (0-200).")
    @app_commands.describe(value="Gi√° tr·ªã √¢m l∆∞·ª£ng t·ª´ 0 ƒë·∫øn 200.")
    async def slash_volume(self, interaction: discord.Interaction, value: app_commands.Range[int, 0, 200]): await self._volume_logic(interaction, value)
    @music_group.command(name="shuffle", description="X√°o tr·ªôn th·ª© t·ª± c√°c b√†i h√°t trong h√†ng ƒë·ª£i.")
    async def slash_shuffle(self, interaction: discord.Interaction):
        state = self.get_guild_state(interaction.guild.id)
        if state.queue.qsize()<2:return await interaction.response.send_message("Kh√¥ng ƒë·ªß b√†i h√°t ƒë·ªÉ x√°o tr·ªôn.", ephemeral=True)
        queue_list=list(state.queue._queue);random.shuffle(queue_list)
        while not state.queue.empty():state.queue.get_nowait()
        for song in queue_list:await state.queue.put(song)
        await interaction.response.send_message("üîÄ ƒê√£ x√°o tr·ªôn h√†ng ƒë·ª£i!")
    @music_group.command(name="remove", description="X√≥a m·ªôt b√†i h√°t kh·ªèi h√†ng ƒë·ª£i.")
    @app_commands.describe(index="S·ªë th·ª© t·ª± c·ªßa b√†i h√°t trong h√†ng ƒë·ª£i (xem b·∫±ng /queue).")
    async def slash_remove(self, interaction: discord.Interaction, index: int):
        state = self.get_guild_state(interaction.guild.id)
        if index <= 0 or index > state.queue.qsize():return await interaction.response.send_message("S·ªë th·ª© t·ª± kh√¥ng h·ª£p l·ªá.", ephemeral=True)
        queue_list=list(state.queue._queue);removed_song=queue_list.pop(index-1);removed_song.cleanup()
        while not state.queue.empty():state.queue.get_nowait()
        for song in queue_list:await state.queue.put(song)
        await interaction.response.send_message(f"üóëÔ∏è ƒê√£ x√≥a **{removed_song.title}** kh·ªèi h√†ng ƒë·ª£i.")
    @music_group.command(name="clear", description="X√≥a t·∫•t c·∫£ b√†i h√°t trong h√†ng ƒë·ª£i.")
    async def slash_clear(self, interaction: discord.Interaction):
        state = self.get_guild_state(interaction.guild.id); count = 0
        while not state.queue.empty():
            try:song=state.queue.get_nowait();song.cleanup();count+=1
            except asyncio.QueueEmpty:break
        await interaction.response.send_message(f"üí• ƒê√£ x√≥a s·∫°ch {count} b√†i h√°t kh·ªèi h√†ng ƒë·ª£i.")
    @music_group.command(name="seek", description="Tua ƒë·∫øn m·ªôt th·ªùi ƒëi·ªÉm trong b√†i h√°t.")
    @app_commands.describe(timestamp="Th·ªùi gian ƒë·ªÉ tua ƒë·∫øn (vd: 1:23 ho·∫∑c 83).")
    async def slash_seek(self, interaction: discord.Interaction, timestamp: str): await self._seek_logic(interaction, timestamp)
    @music_group.command(name="lyrics", description="T√¨m l·ªùi c·ªßa b√†i h√°t ƒëang ph√°t.")
    async def slash_lyrics(self, interaction: discord.Interaction): await self._lyrics_logic(interaction)

async def setup(bot: commands.Bot):
    """Thi·∫øt l·∫≠p v√† ƒëƒÉng k√Ω c√°c cogs v√†o bot."""
    await bot.add_cog(General(bot))
    await bot.add_cog(Music(bot))
    log.info("ƒê√£ th√™m cogs General v√† Music.")
