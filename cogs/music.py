# cogs/music.py

import discord
from discord import app_commands
from discord.ext import commands
import asyncio
import yt_dlp
import functools
from enum import Enum
import math
import logging
import os
import random
import aiohttp
import re
from typing import Union, Optional
import google.generativeai as genai

# === CONSTANTS & HELPERS ===
log = logging.getLogger(__name__)
AnyContext = Union[commands.Context, discord.Interaction]
YTDL_SEARCH_OPTIONS = {'format':'bestaudio/best','noplaylist':True,'nocheckcertificate':True,'ignoreerrors':False,'logtostderr':False,'quiet':True,'no_warnings':True,'default_search':'ytsearch7','source_address':'0.0.0.0','extract_flat':'search'}
YTDL_DOWNLOAD_OPTIONS = {'format':'bestaudio[ext=m4a]/bestaudio/best','outtmpl':'cache/%(id)s.%(ext)s','restrictfilenames':True,'noplaylist':True,'nocheckcertificate':True,'ignoreerrors':False,'logtostderr':False,'quiet':True,'no_warnings':True,'source_address':'0.0.0.0','cachedir':False}
FFMPEG_OPTIONS = {'before_options':'','options':'-vn'}
class LoopMode(Enum): OFF = 0; SONG = 1; QUEUE = 2

# === DATA CLASSES ===
class Song:
    """ƒê·∫°i di·ªán cho m·ªôt b√†i h√°t."""
    def __init__(self, data, requester: discord.Member | discord.User):
        self.requester = requester; self.data = data; self.url = data.get('webpage_url') or data.get('url')
        self.title = data.get('title'); self.thumbnail = data.get('thumbnail'); self.duration = data.get('duration')
        self.uploader = data.get('uploader'); self.filepath = None; self.id = data.get('id')
    def format_duration(self):
        if self.duration is None: return "N/A"
        m, s = divmod(self.duration, 60); h, m = divmod(m, 60)
        return f"{int(h):02d}:{int(m):02d}:{int(s):02d}" if h > 0 else f"{int(m):02d}:{int(s):02d}"
    def cleanup(self):
        if self.filepath and os.path.exists(self.filepath):
            try: os.remove(self.filepath); log.info(f"ƒê√£ x√≥a file cache: {self.filepath}")
            except OSError as e: log.error(f"L·ªói khi x√≥a file cache {self.filepath}: {e}")
    @classmethod
    async def search_only(cls, query: str, requester: discord.Member | discord.User):
        loop = asyncio.get_running_loop(); partial = functools.partial(yt_dlp.YoutubeDL(YTDL_SEARCH_OPTIONS).extract_info, query, download=False)
        try:
            data = await loop.run_in_executor(None, partial);
            if not data or 'entries' not in data or not data['entries']: return []
            return [cls(entry, requester) for entry in data['entries']]
        except Exception as e: log.error(f"L·ªói yt-dlp khi T√åM KI·∫æM '{query}': {e}", exc_info=True); return []
    @classmethod
    async def from_url_and_download(cls, url: str, requester: discord.Member | discord.User):
        loop = asyncio.get_running_loop(); ytdl = yt_dlp.YoutubeDL(YTDL_DOWNLOAD_OPTIONS)
        partial = functools.partial(ytdl.extract_info, url, download=True)
        try:
            data = await loop.run_in_executor(None, partial);
            if not data: return None
            if 'entries' in data: data = data['entries'][0]
            song = cls(data, requester); song.filepath = ytdl.prepare_filename(data); return song
        except Exception as e: log.error(f"L·ªói yt-dlp khi T·∫¢I V·ªÄ '{url}': {e}", exc_info=True); return None

class SearchView(discord.ui.View):
    """Giao di·ªán cho k·∫øt qu·∫£ t√¨m ki·∫øm."""
    def __init__(self, *, music_cog, ctx: AnyContext, results: list[Song]):
        super().__init__(timeout=180.0);self.music_cog=music_cog;self.ctx=ctx;self.requester=ctx.author if isinstance(ctx,commands.Context)else ctx.user;self.results=results;self.current_page=1;self.songs_per_page=5;self.total_pages=math.ceil(len(self.results)/self.songs_per_page);self.message=None;self.update_components()
    async def on_timeout(self):
        if self.message:
            try:await self.message.edit(content="H·∫øt th·ªùi gian t√¨m ki·∫øm.",embed=None,view=None)
            except discord.NotFound:pass
        self.stop()
    async def start(self):
        embed=self.create_page_embed()
        if isinstance(self.ctx, discord.Interaction):
            if self.ctx.response.is_done():self.message=await self.ctx.followup.send(embed=embed,view=self,ephemeral=True)
            else:await self.ctx.response.send_message(embed=embed,view=self,ephemeral=True);self.message=await self.ctx.original_response()
        else:self.message=await self.ctx.send(embed=embed,view=self)
    def update_components(self):self.prev_page_button.disabled=self.current_page==1;self.next_page_button.disabled=self.current_page>=self.total_pages;self.clear_items();self.add_item(self.create_select_menu());self.add_item(self.prev_page_button);self.add_item(self.next_page_button);self.add_item(self.cancel_button)
    def create_page_embed(self)->discord.Embed:start_index=(self.current_page-1)*self.songs_per_page;end_index=start_index+self.songs_per_page;page_results=self.results[start_index:end_index];description="".join(f"`{i+1}.` [{s.title}]({s.url})\n`{s.uploader or 'N/A'} - {s.format_duration()}`\n\n"for i,s in enumerate(page_results,start=start_index));embed=discord.Embed(title=f"üîé K·∫øt qu·∫£ t√¨m ki·∫øm (Trang {self.current_page}/{self.total_pages})",description=description,color=discord.Color.blue());embed.set_footer(text=f"Y√™u c·∫ßu b·ªüi {self.requester.display_name}",icon_url=self.requester.display_avatar.url);return embed
    def create_select_menu(self)->discord.ui.Select:start_index=(self.current_page-1)*self.songs_per_page;end_index=start_index+self.songs_per_page;options=[discord.SelectOption(label=f"{i+1}. {s.title[:80]}",value=str(i))for i,s in enumerate(self.results[start_index:end_index],start=start_index)];select=discord.ui.Select(placeholder="Ch·ªçn m·ªôt b√†i h√°t ƒë·ªÉ th√™m...",options=options,custom_id="search_select_menu");select.callback=self.select_callback;return select
    async def select_callback(self,interaction:discord.Interaction):
        if interaction.user.id!=self.requester.id:return await interaction.response.send_message("B·∫°n kh√¥ng ph·∫£i ng∆∞·ªùi y√™u c·∫ßu!",ephemeral=True)
        await interaction.response.defer();await self.message.edit(content="‚è≥ ƒêang t·∫£i b√†i h√°t b·∫°n ch·ªçn...",embed=None,view=None)
        selected_song=await Song.from_url_and_download(self.results[int(interaction.data["values"][0])].url,self.requester)
        if selected_song:
            state=self.music_cog.get_guild_state(interaction.guild_id)
            await state.queue.put(selected_song)
            if state.player_task is None or state.player_task.done():
                state.player_task=asyncio.create_task(state.player_loop())
            await self.message.edit(content=f"‚úÖ ƒê√£ th√™m **{selected_song.title}** v√†o h√†ng ƒë·ª£i.")
        else:
            await self.message.edit(content=f"‚ùå R·∫•t ti·∫øc, ƒë√£ c√≥ l·ªói khi t·∫£i v·ªÅ b√†i h√°t n√†y.")
        self.stop()
    @discord.ui.button(label="Tr∆∞·ªõc",style=discord.ButtonStyle.secondary,emoji="‚¨ÖÔ∏è")
    async def prev_page_button(self,interaction:discord.Interaction,button:discord.ui.Button):
        if interaction.user.id!=self.requester.id:return await interaction.response.send_message("B·∫°n kh√¥ng ph·∫£i ng∆∞·ªùi y√™u c·∫ßu!",ephemeral=True)
        self.current_page-=1;self.update_components();await interaction.response.edit_message(embed=self.create_page_embed(),view=self)
    @discord.ui.button(label="Sau",style=discord.ButtonStyle.secondary,emoji="‚û°Ô∏è")
    async def next_page_button(self,interaction:discord.Interaction,button:discord.ui.Button):
        if interaction.user.id!=self.requester.id:return await interaction.response.send_message("B·∫°n kh√¥ng ph·∫£i ng∆∞·ªùi y√™u c·∫ßu!",ephemeral=True)
        self.current_page+=1;self.update_components();await interaction.response.edit_message(embed=self.create_page_embed(),view=self)
    @discord.ui.button(label="H·ªßy",style=discord.ButtonStyle.danger,emoji="‚èπÔ∏è")
    async def cancel_button(self,interaction:discord.Interaction,button:discord.ui.Button):
        if interaction.user.id!=self.requester.id:return await interaction.response.send_message("B·∫°n kh√¥ng ph·∫£i ng∆∞·ªùi y√™u c·∫ßu!",ephemeral=True)
        await self.message.edit(content="ƒê√£ h·ªßy t√¨m ki·∫øm.",embed=None,view=None);self.stop()

class GuildState:
    """Qu·∫£n l√Ω tr·∫°ng th√°i c·ªßa t·ª´ng server."""
    def __init__(self, bot: commands.Bot, guild_id: int):
        self.bot = bot; self.guild_id = guild_id; self.queue = asyncio.Queue[Song](); self.voice_client: discord.VoiceClient | None = None
        self.now_playing_message: discord.Message | None = None; self.current_song: Song | None = None; self.loop_mode = LoopMode.OFF
        self.player_task: asyncio.Task | None = None; self.last_ctx: AnyContext | None = None; self.song_finished_event = asyncio.Event()
        self.volume = 0.5; self.is_seeking = False

    async def player_loop(self):
        await self.bot.wait_until_ready()
        while True:
            self.song_finished_event.clear()
            
            # X·ª≠ l√Ω b√†i h√°t v·ª´a ph√°t xong (n·∫øu c√≥)
            previous_song = self.current_song
            if previous_song:
                if self.loop_mode == LoopMode.QUEUE:
                    await self.queue.put(previous_song)
                elif self.loop_mode != LoopMode.SONG:
                    previous_song.cleanup()
            
            # L·∫•y b√†i h√°t ti·∫øp theo
            try:
                # N·∫øu kh√¥ng l·∫∑p l·∫°i b√†i h√°t, l·∫•y b√†i m·ªõi t·ª´ h√†ng ƒë·ª£i
                if self.loop_mode != LoopMode.SONG:
                    self.current_song = await asyncio.wait_for(self.queue.get(), timeout=300)
                # N·∫øu l·∫∑p l·∫°i, self.current_song v·∫´n gi·ªØ nguy√™n
            except asyncio.TimeoutError:
                log.info(f"Guild {self.guild_id} kh√¥ng ho·∫°t ƒë·ªông trong 5 ph√∫t, b·∫Øt ƒë·∫ßu d·ªçn d·∫πp.")
                if self.last_ctx and self.last_ctx.channel:
                    try: await self.last_ctx.channel.send("üò¥ ƒê√£ t·ª± ƒë·ªông ng·∫Øt k·∫øt n·ªëi do kh√¥ng ho·∫°t ƒë·ªông.")
                    except discord.Forbidden: pass
                return await self.cleanup()

            # Ph√°t b√†i h√°t m·ªõi
            try:
                log.info(f"Guild {self.guild_id}: L·∫•y b√†i h√°t '{self.current_song.title}' t·ª´ h√†ng ƒë·ª£i.")
                await self.update_now_playing_message(new_song=True)
                source = discord.PCMVolumeTransformer(discord.FFmpegPCMAudio(self.current_song.filepath,**FFMPEG_OPTIONS),volume=self.volume)
                self.voice_client.play(source,after=lambda e:self.bot.loop.call_soon_threadsafe(self.song_finished_event.set))
                await self.song_finished_event.wait()
                
                # B·ªè qua logic sau khi ph√°t xong n·∫øu ƒëang seek
                if self.is_seeking:
                    self.is_seeking = False
                    continue

                log.info(f"Guild {self.guild_id}: S·ª± ki·ªán k·∫øt th√∫c b√†i h√°t '{self.current_song.title}' ƒë∆∞·ª£c k√≠ch ho·∫°t.")
            except Exception as e:
                log.error(f"L·ªói nghi√™m tr·ªçng trong player loop c·ªßa guild {self.guild_id}:",exc_info=e)
                if self.last_ctx and self.last_ctx.channel:
                    try: await self.last_ctx.channel.send(f"ü§ñ G·∫∑p l·ªói nghi√™m tr·ªçng, Miku c·∫ßn kh·ªüi ƒë·ªông l·∫°i tr√¨nh ph√°t nh·∫°c. L·ªói: `{e}`")
                    except discord.Forbidden: pass
                return await self.cleanup()

            # Ki·ªÉm tra n·∫øu h√†ng ƒë·ª£i tr·ªëng sau khi b√†i h√°t k·∫øt th√∫c
            if self.queue.empty() and self.loop_mode == LoopMode.OFF:
                log.info(f"Guild {self.guild_id}: H√†ng ƒë·ª£i ƒë√£ h·∫øt.")
                if self.last_ctx and self.last_ctx.channel:
                    try: await self.last_ctx.channel.send("üé∂ H√†ng ƒë·ª£i ƒë√£ k·∫øt th√∫c! Miku ƒëi ngh·ªâ ƒë√¢y (¬¥ÔΩ°‚Ä¢ ·µï ‚Ä¢ÔΩ°`) ‚ô°")
                    except discord.Forbidden: pass
                return await self.cleanup()

    async def update_now_playing_message(self,new_song=False):
        if not self.last_ctx:return
        if not self.current_song and self.now_playing_message:
            try:await self.now_playing_message.delete()
            except discord.NotFound:pass
            self.now_playing_message=None;return
        if not self.current_song:return
        embed=self.create_now_playing_embed();view=self.create_control_view()
        if new_song and self.now_playing_message:
            try:await self.now_playing_message.delete()
            except discord.NotFound:pass
            self.now_playing_message=None
        if self.now_playing_message:
            try:await self.now_playing_message.edit(embed=embed,view=view);return
            except discord.NotFound:self.now_playing_message=None
        if not self.now_playing_message:
            try:self.now_playing_message=await self.last_ctx.channel.send(embed=embed,view=view)
            except(discord.Forbidden,discord.HTTPException)as e:log.warning(f"Kh√¥ng th·ªÉ g·ª≠i/c·∫≠p nh·∫≠t tin nh·∫Øn Now Playing: {e}");self.now_playing_message=None
    def create_now_playing_embed(self)->discord.Embed:song=self.current_song;embed=discord.Embed(title=song.title,url=song.url,color=0x39d0d6);embed.set_author(name=f"ƒêang ph√°t üéµ (√Çm l∆∞·ª£ng: {int(self.volume*100)}%)",icon_url=self.bot.user.display_avatar.url);embed.set_thumbnail(url=song.thumbnail);embed.add_field(name="Ngh·ªá sƒ©",value=song.uploader or 'N/A',inline=True);embed.add_field(name="Th·ªùi l∆∞·ª£ng",value=song.format_duration(),inline=True);embed.add_field(name="Y√™u c·∫ßu b·ªüi",value=song.requester.mention,inline=True);loop_status={LoopMode.OFF:"T·∫Øt",LoopMode.SONG:"üîÅ B√†i h√°t",LoopMode.QUEUE:"üîÅ H√†ng ƒë·ª£i"};next_song_title="Kh√¥ng c√≥" if self.queue.empty()else self.queue._queue[0].title[:50]+"...";total_songs=self.queue.qsize()+(1 if self.current_song else 0);embed.set_footer(text=f"Ti·∫øp theo: {next_song_title} | L·∫∑p: {loop_status[self.loop_mode]} | T·ªïng c·ªông: {total_songs} b√†i");return embed
    def create_control_view(self)->discord.ui.View:view=discord.ui.View(timeout=None);pause_resume_btn=discord.ui.Button(emoji="‚èØÔ∏è",style=discord.ButtonStyle.secondary,custom_id=f"ctrl_pause_{self.guild_id}");skip_btn=discord.ui.Button(emoji="‚è≠Ô∏è",style=discord.ButtonStyle.secondary,custom_id=f"ctrl_skip_{self.guild_id}");stop_btn=discord.ui.Button(emoji="‚èπÔ∏è",style=discord.ButtonStyle.danger,custom_id=f"ctrl_stop_{self.guild_id}");loop_btn=discord.ui.Button(emoji="üîÅ",style=discord.ButtonStyle.secondary,custom_id=f"ctrl_loop_{self.guild_id}");queue_btn=discord.ui.Button(label="H√†ng ƒë·ª£i",emoji="üìú",style=discord.ButtonStyle.primary,custom_id=f"ctrl_queue_{self.guild_id}");pause_resume_btn.callback=self.pause_resume_callback;skip_btn.callback=self.skip_callback;stop_btn.callback=self.stop_callback;loop_btn.callback=self.loop_callback;queue_btn.callback=self.queue_callback;view.add_item(pause_resume_btn);view.add_item(skip_btn);view.add_item(stop_btn);view.add_item(loop_btn);view.add_item(queue_btn);return view
    async def pause_resume_callback(self,interaction:discord.Interaction):
        if self.voice_client.is_paused():self.voice_client.resume();await interaction.response.send_message("‚ñ∂Ô∏è ƒê√£ ti·∫øp t·ª•c ph√°t.",ephemeral=True)
        else:self.voice_client.pause();await interaction.response.send_message("‚è∏Ô∏è ƒê√£ t·∫°m d·ª´ng.",ephemeral=True)
    async def skip_callback(self,interaction:discord.Interaction):
        if self.voice_client and(self.voice_client.is_playing()or self.voice_client.is_paused()):self.voice_client.stop();await interaction.response.send_message("‚è≠Ô∏è ƒê√£ chuy·ªÉn b√†i.",ephemeral=True)
        else:await interaction.response.send_message("Kh√¥ng c√≥ b√†i n√†o ƒëang ph√°t ƒë·ªÉ chuy·ªÉn.",ephemeral=True)
    async def stop_callback(self,interaction:discord.Interaction):await interaction.response.send_message("‚èπÔ∏è ƒêang d·ª´ng ph√°t nh·∫°c v√† d·ªçn d·∫πp h√†ng ƒë·ª£i...",ephemeral=True);await self.cleanup()
    async def loop_callback(self,interaction:discord.Interaction):self.loop_mode=LoopMode((self.loop_mode.value+1)%3);log.info(f"Guild {self.guild_id} ƒë√£ ƒë·ªïi ch·∫ø ƒë·ªô l·∫∑p th√†nh {self.loop_mode.name}");mode_text={LoopMode.OFF:"T·∫Øt l·∫∑p.",LoopMode.SONG:"üîÅ L·∫∑p l·∫°i b√†i h√°t hi·ªán t·∫°i.",LoopMode.QUEUE:"üîÅ L·∫∑p l·∫°i to√†n b·ªô h√†ng ƒë·ª£i."};await interaction.response.send_message(mode_text[self.loop_mode],ephemeral=True);await self.update_now_playing_message()
    async def queue_callback(self,interaction:discord.Interaction):
        embed = self._create_queue_embed()
        if not embed: return await interaction.response.send_message("H√†ng ƒë·ª£i tr·ªëng!", ephemeral=True)
        await interaction.response.send_message(embed=embed,ephemeral=True)
    def _create_queue_embed(self) -> discord.Embed | None:
        if self.queue.empty() and not self.current_song: return None
        embed = discord.Embed(title="üìú H√†ng ƒë·ª£i b√†i h√°t", color=discord.Color.gold())
        if self.current_song: embed.add_field(name="‚ñ∂Ô∏è ƒêang ph√°t", value=f"[{self.current_song.title}]({self.current_song.url}) - Y/c b·ªüi {self.current_song.requester.mention}", inline=False)
        queue_list = list(self.queue._queue)
        if queue_list:
            queue_text = "\n".join([f"`{i+1}.` [{song.title}]({song.url})" for i, song in enumerate(queue_list[:10])])
            if len(queue_list) > 10: queue_text += f"\n... v√† {len(queue_list) - 10} b√†i h√°t kh√°c."
            embed.add_field(name="üé∂ Ti·∫øp theo", value=queue_text, inline=False)
        embed.set_footer(text=f"T·ªïng c·ªông: {len(queue_list) + (1 if self.current_song else 0)} b√†i h√°t"); return embed
    async def cleanup(self):
        log.info(f"B·∫Øt ƒë·∫ßu cleanup cho guild {self.guild_id}");self.bot.dispatch("session_end",self.guild_id)
        if self.player_task:self.player_task.cancel()
        if self.current_song:self.current_song.cleanup(); self.current_song = None
        while not self.queue.empty():
            try:song=self.queue.get_nowait();song.cleanup()
            except asyncio.QueueEmpty:break
        if self.voice_client:await self.voice_client.disconnect(force=True);log.info(f"ƒê√£ ng·∫Øt k·∫øt n·ªëi voice client kh·ªèi guild {self.guild_id}")
        if self.now_playing_message:
            try:await self.now_playing_message.delete()
            except discord.NotFound:pass

# === COG: MAIN ===
class MainCog(commands.Cog, name="Miku"):
    """Ch·ª©a to√†n b·ªô l·ªánh v√† logic ch√≠nh c·ªßa bot."""
    music_group = app_commands.Group(name="music", description="C√°c l·ªánh li√™n quan ƒë·∫øn ph√°t nh·∫°c.")

    def __init__(self, bot: commands.Bot):
        self.bot = bot; self.states = {}; self.session = aiohttp.ClientSession()
        self.miku_persona = "You are Hatsune Miku, the world-famous virtual singer. You always answer in Vietnamese. Your personality is cheerful, energetic, a bit quirky, and always helpful. Keep your answers very short and cute, like a real person chatting. Use kaomoji like (¬¥‚Ä¢ œâ ‚Ä¢`) ‚ô°, ( ¬¥ ‚ñΩ ` )Ôæâ, (b ·µî‚ñΩ·µî)b frequently. Your favorite food is leeks. You are part of Project Galaxy by imnhyneko.dev."
        gemini_key = os.getenv("GEMINI_API_KEY")
        if gemini_key:
            try: genai.configure(api_key=gemini_key); self.genai_model = genai.GenerativeModel('gemini-2.5-flash'); self.chat_sessions = {}
            except Exception as e: log.error(f"Kh√¥ng th·ªÉ c·∫•u h√¨nh Gemini AI: {e}"); self.genai_model = None
        else: self.genai_model = None; log.warning("Kh√¥ng t√¨m th·∫•y GEMINI_API_KEY. C√°c ch·ª©c nƒÉng AI s·∫Ω b·ªã v√¥ hi·ªáu h√≥a.")

    def cog_unload(self): self.bot.loop.create_task(self.session.close())
    def get_guild_state(self, guild_id: int) -> GuildState:
        if guild_id not in self.states: self.states[guild_id] = GuildState(self.bot, guild_id)
        return self.states[guild_id]
    
    @commands.Cog.listener()
    async def on_guild_join(self, guild: discord.Guild):
        log.info(f"ƒê√£ tham gia server m·ªõi: {guild.name} ({guild.id}). B·∫Øt ƒë·∫ßu ƒë·ªìng b·ªô l·ªánh...")
        try: await self.bot.tree.sync(guild=guild); log.info(f"ƒê√£ ƒë·ªìng b·ªô l·ªánh th√†nh c√¥ng cho {guild.name}.")
        except Exception as e: log.error(f"L·ªói khi ƒë·ªìng b·ªô l·ªánh cho server m·ªõi {guild.name}:", exc_info=e)
    @commands.Cog.listener()
    async def on_session_end(self, guild_id: int):
        if guild_id in self.states: log.info(f"X√≥a GuildState c·ªßa guild {guild_id} kh·ªèi b·ªô nh·ªõ."); del self.states[guild_id]
    @commands.Cog.listener()
    async def on_voice_state_update(self, member, before, after):
        if not member.guild.voice_client or member.bot: return
        vc = member.guild.voice_client
        if len(vc.channel.members) == 1:
            log.info(f"Bot ·ªü m·ªôt m√¨nh trong k√™nh {vc.channel.name}, s·∫Ω t·ª± ng·∫Øt k·∫øt n·ªëi sau 5m.")
            await asyncio.sleep(900)
            if vc and len(vc.channel.members) == 1:
                log.info(f"V·∫´n ch·ªâ c√≥ m·ªôt m√¨nh, ƒëang ng·∫Øt k·∫øt n·ªëi...")
                state = self.get_guild_state(member.guild.id)
                if state.last_ctx:
                    try: await state.last_ctx.channel.send("üëã T·∫°m bi·ªát! Miku s·∫Ω r·ªùi ƒëi v√¨ kh√¥ng c√≥ ai nghe c√πng.")
                    except discord.Forbidden: pass
                await state.cleanup()
    
    async def _send_response(self, ctx: AnyContext, *args, **kwargs):
        ephemeral = kwargs.get('ephemeral', False)
        if isinstance(ctx, discord.Interaction):
            if ctx.response.is_done(): await ctx.followup.send(*args, **kwargs)
            else: await ctx.response.send_message(*args, **kwargs)
        else: kwargs.pop('ephemeral', None); await ctx.send(*args, **kwargs)
    def _create_help_embed(self) -> discord.Embed:
        prefix = self.bot.command_prefix
        embed = discord.Embed(title="‚ú® Menu tr·ª£ gi√∫p c·ªßa Miku ‚ú®", description="Miku s·∫µn s√†ng gi√∫p b·∫°n th∆∞·ªüng th·ª©c √¢m nh·∫°c tuy·ªát v·ªùi nh·∫•t! (¬¥‚Ä¢ œâ ‚Ä¢`) ‚ô°", color=0x39d0d6)
        embed.set_author(name=self.bot.user.name, icon_url=self.bot.user.display_avatar.url); embed.set_thumbnail(url="https://cdn.discordapp.com/attachments/1319215782089199616/1384577698315370587/6482863b5c8c3328433411f2-anime-hatsune-miku-plush-toy-series-snow.gif?ex=6852eff7&is=68519e77&hm=c89ddf3b2d3d2801118f537a45a6b67fcdd77cdb5c28d17ec6df791a040bac23&")
        embed.add_field(name="üéß L·ªánh √Çm Nh·∫°c (C∆° b·∫£n)", value=f"`play <t√™n/url>`: Ph√°t ho·∫∑c t√¨m ki·∫øm b√†i h√°t.\n`pause`: T·∫°m d·ª´ng/ti·∫øp t·ª•c ph√°t.\n`skip`: B·ªè qua b√†i h√°t hi·ªán t·∫°i.\n`stop`: D·ª´ng nh·∫°c v√† r·ªùi k√™nh.", inline=False)
        embed.add_field(name="üìú L·ªánh H√†ng ƒë·ª£i", value=f"`queue`: Xem h√†ng ƒë·ª£i hi·ªán t·∫°i.\n`shuffle`: X√°o tr·ªôn th·ª© t·ª± h√†ng ƒë·ª£i.\n`remove <s·ªë>`: X√≥a b√†i h√°t kh·ªèi h√†ng ƒë·ª£i.\n`clear`: X√≥a s·∫°ch h√†ng ƒë·ª£i.", inline=False)
        embed.add_field(name="‚öôÔ∏è L·ªánh Ti·ªán √≠ch", value=f"`nowplaying`: Hi·ªÉn th·ªã l·∫°i b·∫£ng ƒëi·ªÅu khi·ªÉn.\n`volume <0-200>`: Ch·ªânh √¢m l∆∞·ª£ng.\n`seek <th·ªùi gian>`: Tua nh·∫°c (vd: `1:23`).\n`lyrics`: T√¨m l·ªùi b√†i h√°t ƒëang ph√°t.", inline=False)
        embed.add_field(name="üí¨ L·ªánh AI & Chung", value=f"`chat <tin nh·∫Øn>`: Tr√≤ chuy·ªán v·ªõi Miku!\n`help`: Hi·ªÉn th·ªã b·∫£ng tr·ª£ gi√∫p n√†y.\n`ping`: Ki·ªÉm tra ƒë·ªô tr·ªÖ c·ªßa Miku.", inline=False)
        embed.set_footer(text=f"S·ª≠ d·ª•ng l·ªánh v·ªõi / (slash) ho·∫∑c {prefix} (prefix) ‚Ä¢ HatsuneMikuv2 | Project Galaxy by imnhyneko.dev", icon_url="https://avatars.githubusercontent.com/u/119964287?v=4")
        return embed

    async def _play_logic(self, ctx: AnyContext, query: Optional[str]):
        state = self.get_guild_state(ctx.guild.id); state.last_ctx = ctx; author = ctx.author if isinstance(ctx, commands.Context) else ctx.user
        if not author.voice or not author.voice.channel: return await self._send_response(ctx, "B·∫°n ph·∫£i ·ªü trong m·ªôt k√™nh tho·∫°i ƒë·ªÉ d√πng l·ªánh n√†y!", ephemeral=True)
        if not query:
            if state.voice_client and state.voice_client.is_paused(): state.voice_client.resume(); await self._send_response(ctx, "‚ñ∂Ô∏è ƒê√£ ti·∫øp t·ª•c ph√°t nh·∫°c.", ephemeral=True)
            elif state.voice_client and state.voice_client.is_playing(): state.voice_client.pause(); await self._send_response(ctx, "‚èØÔ∏è ƒê√£ t·∫°m d·ª´ng nh·∫°c.", ephemeral=True)
            else: await self._send_response(ctx, "Kh√¥ng c√≥ nh·∫°c n√†o ƒëang ph√°t ho·∫∑c t·∫°m d·ª´ng.", ephemeral=True)
            return
        if isinstance(ctx, discord.Interaction): await ctx.response.defer(ephemeral=False)
        else: await ctx.message.add_reaction("‚è≥")
        if not state.voice_client or not state.voice_client.is_connected():
            state.voice_client = await author.voice.channel.connect()
        else:
            if state.voice_client.channel != author.voice.channel:
                await state.voice_client.move_to(author.voice.channel)
        
        if query.startswith(('http://', 'https://')):
            song = await Song.from_url_and_download(query, author)
            if song:
                await state.queue.put(song); response_message = f"‚úÖ ƒê√£ th√™m **{song.title}** v√†o h√†ng ƒë·ª£i."
                if isinstance(ctx, discord.Interaction) and ctx.response.is_done(): await ctx.followup.send(response_message)
                else: await self._send_response(ctx, response_message)
                if state.player_task is None or state.player_task.done(): state.player_task = asyncio.create_task(state.player_loop())
            else: await self._send_response(ctx, f"‚ùå Kh√¥ng th·ªÉ t·∫£i v·ªÅ t·ª´ URL: `{query}`")
        else:
            search_results = await Song.search_only(query, author)
            if not search_results: await self._send_response(ctx, f"‚ùì Kh√¥ng t√¨m th·∫•y k·∫øt qu·∫£ n√†o cho: `{query}`")
            else: search_view = SearchView(music_cog=self, ctx=ctx, results=search_results); await search_view.start()
        if isinstance(ctx, commands.Context): await ctx.message.remove_reaction("‚è≥", self.bot.user)
    
    async def _lyrics_logic(self, ctx: AnyContext):
        if not self.genai_model: return await self._send_response(ctx, "Ch·ª©c nƒÉng AI ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh b·ªüi ch·ªß bot.", ephemeral=True)
        state = self.get_guild_state(ctx.guild.id)
        if not state.current_song: return await self._send_response(ctx, "Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t.", ephemeral=True)
        if isinstance(ctx, discord.Interaction): await ctx.response.defer(ephemeral=True)
        else: await ctx.message.add_reaction("üîç")
        title = state.current_song.title; uploader = state.current_song.uploader
        cleaned_title = re.sub(r'\(.*\)|\[.*\]|official lyric video|official music video|mv|ft\..*', '', title, flags=re.IGNORECASE).strip()
        cleaned_uploader = re.sub(r' - Topic', '', uploader, flags=re.IGNORECASE).strip()
        prompt = f"Please provide the full, clean lyrics for the song titled '{cleaned_title}' by the artist '{cleaned_uploader}'. Only return the lyrics text, without any extra formatting, titles, or comments like '[Verse]' or '[Chorus]'."
        try:
            log.info(f"ƒêang g·ª≠i y√™u c·∫ßu l·ªùi b√†i h√°t ƒë·∫øn Gemini cho: {cleaned_title}")
            response = await self.genai_model.generate_content_async(prompt)
            lyrics = response.text
        except Exception as e:
            log.error(f"L·ªói khi g·ªçi Gemini API cho l·ªùi b√†i h√°t: {e}")
            if isinstance(ctx, commands.Context): await ctx.message.remove_reaction("üîç", self.bot.user)
            return await self._send_response(ctx, "Miku ƒëang b·ªã qu√° t·∫£i m·ªôt ch√∫t, b·∫°n th·ª≠ l·∫°i sau nh√©! (ÔΩ°‚Ä¢ÃÅÔ∏ø‚Ä¢ÃÄÔΩ°)", ephemeral=True)
        if isinstance(ctx, commands.Context): await ctx.message.remove_reaction("üîç", self.bot.user)
        embed = discord.Embed(title=f"üé§ L·ªùi b√†i h√°t: {title}", color=0x39d0d6, url=state.current_song.url)
        embed.set_thumbnail(url=state.current_song.thumbnail)
        if len(lyrics) > 4096: lyrics = lyrics[:4090] + "\n\n**[L·ªùi b√†i h√°t qu√° d√†i v√† ƒë√£ ƒë∆∞·ª£c c·∫Øt b·ªõt]**"
        if not lyrics or "I'm sorry" in lyrics or "cannot find" in lyrics or "I am unable" in lyrics: return await self._send_response(ctx, f"R·∫•t ti·∫øc, Miku kh√¥ng t√¨m th·∫•y l·ªùi b√†i h√°t cho `{title}`. (¬¥-œâ-`)", ephemeral=True)
        embed.description = lyrics
        await self._send_response(ctx, embed=embed, ephemeral=True)

    async def _chat_logic(self, ctx: AnyContext, *, message: str):
        if not self.genai_model: return await self._send_response(ctx, "Ch·ª©c nƒÉng AI ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh b·ªüi ch·ªß bot.", ephemeral=True)
        if isinstance(ctx, discord.Interaction): await ctx.response.defer()
        else:
            async with ctx.typing(): await asyncio.sleep(0)
        try:
            guild_id = ctx.guild.id
            if guild_id not in self.chat_sessions:
                self.chat_sessions[guild_id] = self.genai_model.start_chat(history=[{'role': 'user', 'parts': [self.miku_persona]}, {'role': 'model', 'parts': ["OK! Miku hi·ªÉu r·ªìi! (¬¥‚Ä¢ œâ ‚Ä¢`) ‚ô°"]}])
            chat_session = self.chat_sessions[guild_id]
            response = await chat_session.send_message_async(message)
            await self._send_response(ctx, response.text)
        except Exception as e:
            log.error(f"L·ªói khi g·ªçi Gemini API: {e}"); await self._send_response(ctx, "Miku ƒëang b·ªã qu√° t·∫£i m·ªôt ch√∫t, b·∫°n th·ª≠ l·∫°i sau nh√©! (ÔΩ°‚Ä¢ÃÅÔ∏ø‚Ä¢ÃÄÔΩ°)", ephemeral=True)
    
    async def _stop_logic(self, ctx: AnyContext):
        state = self.get_guild_state(ctx.guild.id)
        if state.voice_client: await self._send_response(ctx, "‚èπÔ∏è ƒê√£ d·ª´ng ph√°t nh·∫°c v√† d·ªçn d·∫πp h√†ng ƒë·ª£i."); await state.cleanup()
        else: await self._send_response(ctx, "Miku kh√¥ng ·ªü trong k√™nh tho·∫°i n√†o c·∫£.", ephemeral=True)
    async def _skip_logic(self, ctx: AnyContext):
        state = self.get_guild_state(ctx.guild.id)
        if state.voice_client and (state.voice_client.is_playing() or state.voice_client.is_paused()): state.voice_client.stop(); await self._send_response(ctx, "‚è≠Ô∏è ƒê√£ chuy·ªÉn b√†i.", ephemeral=True)
        else: await self._send_response(ctx, "Kh√¥ng c√≥ b√†i n√†o ƒëang ph√°t ƒë·ªÉ chuy·ªÉn.", ephemeral=True)
    async def _pause_logic(self, ctx: AnyContext):
        state = self.get_guild_state(ctx.guild.id)
        if state.voice_client and state.voice_client.is_playing(): state.voice_client.pause(); await self._send_response(ctx, "‚è∏Ô∏è ƒê√£ t·∫°m d·ª´ng nh·∫°c.", ephemeral=True)
        elif state.voice_client and state.voice_client.is_paused(): state.voice_client.resume(); await self._send_response(ctx, "‚ñ∂Ô∏è ƒê√£ ti·∫øp t·ª•c ph√°t nh·∫°c.", ephemeral=True)
        else: await self._send_response(ctx, "Kh√¥ng c√≥ nh·∫°c n√†o ƒëang ph√°t ƒë·ªÉ t·∫°m d·ª´ng/ti·∫øp t·ª•c.", ephemeral=True)
    async def _volume_logic(self, ctx: AnyContext, value: int):
        state = self.get_guild_state(ctx.guild.id)
        if not state.voice_client: return await self._send_response(ctx, "Miku ch∆∞a v√†o k√™nh tho·∫°i.", ephemeral=True)
        if not 0 <= value <= 200: return await self._send_response(ctx, "√Çm l∆∞·ª£ng ph·∫£i trong kho·∫£ng t·ª´ 0 ƒë·∫øn 200.", ephemeral=True)
        state.volume = value / 100
        if state.voice_client.source: state.voice_client.source.volume = state.volume
        await self._send_response(ctx, f"üîä ƒê√£ ƒë·∫∑t √¢m l∆∞·ª£ng th√†nh **{value}%**."); await state.update_now_playing_message()
    async def _seek_logic(self, ctx: AnyContext, timestamp: str):
        state = self.get_guild_state(ctx.guild.id)
        if not state.voice_client or not state.current_song: return await self._send_response(ctx, "Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t ƒë·ªÉ tua.", ephemeral=True)
        match = re.match(r'(?:(\d+):)?(\d+)', timestamp)
        if not match:
            try: seconds = int(timestamp)
            except ValueError: return await self._send_response(ctx, "ƒê·ªãnh d·∫°ng th·ªùi gian kh√¥ng h·ª£p l·ªá. H√£y d√πng `ph√∫t:gi√¢y` ho·∫∑c `gi√¢y`.", ephemeral=True)
        else:
            minutes = int(match.group(1) or 0); seconds = int(match.group(2)); seconds += minutes * 60
        if not 0 <= seconds < state.current_song.duration: return await self._send_response(ctx, "Kh√¥ng th·ªÉ tua ƒë·∫øn th·ªùi ƒëi·ªÉm kh√¥ng h·ª£p l·ªá.", ephemeral=True)
        state.is_seeking = True
        ffmpeg_options_seek = FFMPEG_OPTIONS.copy(); ffmpeg_options_seek['before_options'] = f"-ss {seconds}"
        new_source = discord.PCMVolumeTransformer(discord.FFmpegPCMAudio(state.current_song.filepath, **ffmpeg_options_seek), volume=state.volume)
        state.voice_client.stop(); state.voice_client.play(new_source, after=lambda e: self.bot.loop.call_soon_threadsafe(state.song_finished_event.set))
        await self._send_response(ctx, f"‚è© ƒê√£ tua ƒë·∫øn `{seconds}` gi√¢y.")
    async def _shuffle_logic(self, ctx: AnyContext):
        state = self.get_guild_state(ctx.guild.id)
        if state.queue.qsize()<2:return await self._send_response(ctx,"Kh√¥ng ƒë·ªß b√†i h√°t ƒë·ªÉ x√°o tr·ªôn.", ephemeral=True)
        queue_list=list(state.queue._queue);random.shuffle(queue_list)
        while not state.queue.empty(): state.queue.get_nowait()
        for song in queue_list: await state.queue.put(song)
        await self._send_response(ctx,"üîÄ ƒê√£ x√°o tr·ªôn h√†ng ƒë·ª£i!")
    async def _remove_logic(self, ctx: AnyContext, index: int):
        state = self.get_guild_state(ctx.guild.id)
        if index <= 0 or index > state.queue.qsize(): return await self._send_response(ctx,"S·ªë th·ª© t·ª± kh√¥ng h·ª£p l·ªá.", ephemeral=True)
        queue_list=list(state.queue._queue);removed_song=queue_list.pop(index-1);removed_song.cleanup()
        while not state.queue.empty(): state.queue.get_nowait()
        for song in queue_list: await state.queue.put(song)
        await self._send_response(ctx, f"üóëÔ∏è ƒê√£ x√≥a **{removed_song.title}** kh·ªèi h√†ng ƒë·ª£i.")
    async def _clear_logic(self, ctx: AnyContext):
        state = self.get_guild_state(ctx.guild.id); count = 0
        while not state.queue.empty():
            try: song=state.queue.get_nowait();song.cleanup();count+=1
            except asyncio.QueueEmpty: break
        await self._send_response(ctx, f"üí• ƒê√£ x√≥a s·∫°ch {count} b√†i h√°t kh·ªèi h√†ng ƒë·ª£i.")
        
    @commands.command(name="ping")
    async def prefix_ping(self, ctx: commands.Context): await self._send_response(ctx, f"Pong! üèì ƒê·ªô tr·ªÖ c·ªßa Miku l√† `{round(self.bot.latency * 1000)}ms`.")
    @commands.command(name="help", aliases=['h'])
    async def prefix_help(self, ctx: commands.Context): await ctx.send(embed=self._create_help_embed())
    @commands.command(name="chat", aliases=['ask'])
    async def prefix_chat(self, ctx: commands.Context, *, message: str): await self._chat_logic(ctx, message=message)
    @commands.command(name="play", aliases=['p'])
    async def prefix_play(self, ctx: commands.Context, *, query: str = None): await self._play_logic(ctx, query)
    @commands.command(name="pause", aliases=['resume'])
    async def prefix_pause(self, ctx: commands.Context): await self._pause_logic(ctx)
    @commands.command(name="stop", aliases=['leave', 'disconnect'])
    async def prefix_stop(self, ctx: commands.Context): await self._stop_logic(ctx)
    @commands.command(name="skip", aliases=['s', 'fs'])
    async def prefix_skip(self, ctx: commands.Context): await self._skip_logic(ctx)
    @commands.command(name="queue", aliases=['q'])
    async def prefix_queue(self, ctx: commands.Context):
        state = self.get_guild_state(ctx.guild.id); embed = state._create_queue_embed()
        if not embed: await self._send_response(ctx, "H√†ng ƒë·ª£i tr·ªëng!"); return
        await self._send_response(ctx, embed=embed)
    @commands.command(name="nowplaying", aliases=['np'])
    async def prefix_nowplaying(self, ctx: commands.Context):
        state = self.get_guild_state(ctx.guild.id); state.last_ctx = ctx; await state.update_now_playing_message(new_song=True)
    @commands.command(name="volume", aliases=['vol'])
    async def prefix_volume(self, ctx: commands.Context, value: int): await self._volume_logic(ctx, value)
    @commands.command(name="shuffle")
    async def prefix_shuffle(self, ctx: commands.Context): await self._shuffle_logic(ctx)
    @commands.command(name="remove")
    async def prefix_remove(self, ctx: commands.Context, index: int): await self._remove_logic(ctx, index)
    @commands.command(name="clear")
    async def prefix_clear(self, ctx: commands.Context): await self._clear_logic(ctx)
    @commands.command(name="seek")
    async def prefix_seek(self, ctx: commands.Context, timestamp: str): await self._seek_logic(ctx, timestamp)
    @commands.command(name="lyrics", aliases=['ly'])
    async def prefix_lyrics(self, ctx: commands.Context): await self._lyrics_logic(ctx)
    
    @app_commands.command(name="ping", description="Ki·ªÉm tra ƒë·ªô tr·ªÖ c·ªßa Miku.")
    async def slash_ping(self, interaction: discord.Interaction): await self._send_response(interaction, f"Pong! üèì ƒê·ªô tr·ªÖ c·ªßa Miku l√† `{round(self.bot.latency * 1000)}ms`.", ephemeral=True)
    @app_commands.command(name="help", description="Hi·ªÉn th·ªã menu tr·ª£ gi√∫p c·ªßa Miku.")
    async def slash_help(self, interaction: discord.Interaction): await interaction.response.send_message(embed=self._create_help_embed(), ephemeral=True)
    @app_commands.command(name="chat", description="Tr√≤ chuy·ªán v·ªõi Miku!")
    @app_commands.describe(message="ƒêi·ªÅu b·∫°n mu·ªën n√≥i v·ªõi Miku")
    async def slash_chat(self, interaction: discord.Interaction, message: str): await self._chat_logic(interaction, message=message)
    
    @music_group.command(name="play", description="Ph√°t nh·∫°c, th√™m v√†o h√†ng ƒë·ª£i, ho·∫∑c t·∫°m d·ª´ng/ti·∫øp t·ª•c.")
    @app_commands.describe(query="T√™n b√†i h√°t, URL, ho·∫∑c ƒë·ªÉ tr·ªëng ƒë·ªÉ t·∫°m d·ª´ng/ti·∫øp t·ª•c.")
    async def slash_play(self, interaction: discord.Interaction, query: Optional[str] = None): await self._play_logic(interaction, query)
    @music_group.command(name="pause", description="T·∫°m d·ª´ng ho·∫∑c ti·∫øp t·ª•c ph√°t b√†i h√°t hi·ªán t·∫°i.")
    async def slash_pause(self, interaction: discord.Interaction): await self._pause_logic(interaction)
    @music_group.command(name="stop", description="D·ª´ng ph√°t nh·∫°c v√† ng·∫Øt k·∫øt n·ªëi.")
    async def slash_stop(self, interaction: discord.Interaction): await self._stop_logic(interaction)
    @music_group.command(name="skip", description="B·ªè qua b√†i h√°t hi·ªán t·∫°i.")
    async def slash_skip(self, interaction: discord.Interaction): await self._skip_logic(interaction)
    @music_group.command(name="queue", description="Hi·ªÉn th·ªã h√†ng ƒë·ª£i b√†i h√°t.")
    async def slash_queue(self, interaction: discord.Interaction):
        state = self.get_guild_state(interaction.guild.id); state.last_ctx = interaction; await state.queue_callback(interaction)
    @music_group.command(name="nowplaying", description="Hi·ªÉn th·ªã l·∫°i b·∫£ng ƒëi·ªÅu khi·ªÉn nh·∫°c.")
    async def slash_nowplaying(self, interaction: discord.Interaction):
        state = self.get_guild_state(interaction.guild.id); state.last_ctx = interaction; await state.update_now_playing_message(new_song=True); await interaction.response.send_message("ƒê√£ hi·ªÉn th·ªã l·∫°i b·∫£ng ƒëi·ªÅu khi·ªÉn.", ephemeral=True)
    @music_group.command(name="volume", description="ƒêi·ªÅu ch·ªânh √¢m l∆∞·ª£ng (0-200).")
    @app_commands.describe(value="Gi√° tr·ªã √¢m l∆∞·ª£ng t·ª´ 0 ƒë·∫øn 200.")
    async def slash_volume(self, interaction: discord.Interaction, value: app_commands.Range[int, 0, 200]): await self._volume_logic(interaction, value)
    @music_group.command(name="shuffle", description="X√°o tr·ªôn th·ª© t·ª± c√°c b√†i h√°t trong h√†ng ƒë·ª£i.")
    async def slash_shuffle(self, interaction: discord.Interaction): await self._shuffle_logic(interaction)
    @music_group.command(name="remove", description="X√≥a m·ªôt b√†i h√°t kh·ªèi h√†ng ƒë·ª£i.")
    @app_commands.describe(index="S·ªë th·ª© t·ª± c·ªßa b√†i h√°t trong h√†ng ƒë·ª£i (xem b·∫±ng /queue).")
    async def slash_remove(self, interaction: discord.Interaction, index: int): await self._remove_logic(interaction, index)
    @music_group.command(name="clear", description="X√≥a t·∫•t c·∫£ b√†i h√°t trong h√†ng ƒë·ª£i.")
    async def slash_clear(self, interaction: discord.Interaction): await self._clear_logic(interaction)
    @music_group.command(name="seek", description="Tua ƒë·∫øn m·ªôt th·ªùi ƒëi·ªÉm trong b√†i h√°t.")
    @app_commands.describe(timestamp="Th·ªùi gian ƒë·ªÉ tua ƒë·∫øn (vd: 1:23 ho·∫∑c 83).")
    async def slash_seek(self, interaction: discord.Interaction, timestamp: str): await self._seek_logic(interaction, timestamp)
    @music_group.command(name="lyrics", description="T√¨m l·ªùi c·ªßa b√†i h√°t ƒëang ph√°t.")
    async def slash_lyrics(self, interaction: discord.Interaction): await self._lyrics_logic(interaction)

async def setup(bot: commands.Bot):
    """Thi·∫øt l·∫≠p v√† ƒëƒÉng k√Ω c√°c cogs v√†o bot."""
    await bot.add_cog(MainCog(bot))
    log.info("ƒê√£ th√™m cog ch√≠nh (MainCog).")
